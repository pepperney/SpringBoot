#### 线程安全性
1. 编写线程安全的代码实质上就是管理对状态的访问，而且通常都是**共享的**，**可变的**状态。
2. 一个对象的状态就是他的数据，存储在状态变量中，比如实例域或静态域。所谓**共享**是指一个对象可以被多个线程访问；所谓**可变**是指变量
的值在其生命周期之内可以改变。
3. 无论何时只要多于一个线程访问给定的状态变量，而且其中的某个线程会写入该变量，此时必须使用同步来协调该线程对该变量的访问。java中首要
的同步机制是synchronized的关键字，它提供了独占锁。除此之外，术语“同步”还包括volatile关键字，显示锁和原子变量的使用。
4. 在没有正确使用同步的情况下，如果多个线程访问同一个变量，可以使用如下三种方式修复：
    - 不要跨线程共享变量
    - 使状态变量为不可变的
    - 在任何访问状态变量的时候同步
5. 无状态对象永远是线程安全的，多数servlet都可以实现为无状态的，这一事实也极大的降低了servlet线程安全的负担。

#### 原子性
1. 自增操作是三个离散操作的简写形式：获得当前值；加1；写回新值。
2. 原子操作：假设有操作A和操作B，如果从执行A的角度看，当其他的线程执行B时，要么B全部执行完成，要么B一点都没有执行，这样A和B互为原子操
作，一个原子操作是指：该操作对于所有的操作包括他自己都满足前面描述的状态。java.util.concurrent.atomic包中包含了原子类。

#### 锁
1. 一个synchronized代码块包括两个部分：锁对象的引用，以及这个锁保护的代码块. 
2. 每个java对象都隐式的扮演了一个同步锁的角色，称为内部锁或者监视器锁。**执行线程进入synchronized块之前会自动获得锁；而无论线程正
常退出还是在块中抛出异常都会自动释放锁**。获得内部锁的唯一途径就是进入这个内部所保护的同步方法或者同步代码块。
    - **内部锁在java中扮演了互斥锁的角色。意味着至多有一个线程可以拥有锁，其他线程访问必须等待或者阻塞**。
    - **内部锁是可重入的**，因此线程在获取他自己占有的锁时，请求会成功。重新进入意味着所有请求是“每线程”的而不是“每调用”的。重新进入
    的实现是通过为每个锁关联一个请求计数器和一个占有他的线程。当技术为0认为锁是未被占有的，线程请求一个未被占有的锁的时候，jvm将记录锁
    的占有者，并将请求计数置为1，如果同一个线程再次请求这个锁，计数将递增。线程退出则递减。计数为0的时候锁被释放。
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    