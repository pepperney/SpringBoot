1. 重排序：在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，它需要满足以下两个条件： 
    - 在单线程环境下不能改变程序运行的结果； 
    - 存在数据依赖关系的不允许重排序
    
    这两点可以归结于一点：无法通过happens-before原则推导出来的，JMM允许任意的排序。因此，在单线程中只要排序不会对结果产生影响，那么
    就不能保证其中的操作一定是按照程序写定的顺序执行的。
2. as-if-serial:意思是，所有的操作均可以为了优化而被重排序，但是你必须要保证重排序后执行的结果不能被改变，编译器、runtime、处理器都
必须遵守as-if-serial语义。注意as-if-serial只保证单线程环境，多线程环境下无效。
3. 以下情况对过期数据尤其敏感：当一个线程调用了set，而另一个线程此时正在调用get，它可能就看不到最新的数据了。
4. java存储模型要求存储和获取操作都是原子的，但是对于非volatile的64位数值变量(double,long)，jvm允许将64位的数值读或写分为两个32位
的操作。如果读和写发生在两个不同的线程，这种情况读取一个非volatile的64位数值可能会得到一个值的高32位和另一个值的低32位。因此，**在多线
程环境下使用共享的，可变的long和double变量需要声明为volatile的或者用锁保护起来**。
5. **锁不仅仅是关于同步和互斥的，也是关于内存可见的。为了保证所有线程都能看到共享的，可变变量的最新值，读取和写入线程必须使用公
共的锁同步**
6. volatile是轻量级的同步实现，它确保对一个变量的更新以可预见的方式告知其他线程，当一个域声明为volatile的时候，编译器和运行时会监视这
个变量：它是共享的。而且对他的操作不会与其他的内存操作一起被重排序。正确使用volatile的方式包括：用于确保它们所引用的对象状态的可见性，
或者用于标识重要的生命周期事件（比如初始化或关闭）的发生。
7. **加锁可以保证可见性和原子性，volatile只能保证可见性**。只有满足下面的标准之后才可以使用volatile：
    
    - 写入变量的时候并不依赖变量的当前值；或者能够确保只有单一的线程修改变量的值。
    - 变量不需要与其他的状态变量共同参与不变约束
    - 访问变量时，没有其他的原因需要加锁
8. ThreadLocal允许你将每个线程与持有数值的对象关联到一起。ThreadLocal提供了get与set方法，为每个使用它的线程维护一份单独的拷贝。所以
**get总是返回当前线程通过set设置的最新值**。
9. 不可变对象永远是线程安全的。不可变性不等于将对象中所有的域都声明为final类型的，所有域都是final类型的对象仍然是可以改变的，因为
final域可以获得一个到可变对象的引用。只有满足如下状态，一个对象才是不可变的。
    - 它的状态不能在创建后被修改
    - 所有域都是final类型
    - 被正确创建（创建期间没有发生this引用逸出）
    
10. 为了安全的发布对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确创建的对象可以通过如下条件安全的发布：
    - 通过静态初始化器初始化对象的引用
    - 将它的引用存储到volatile域或者`AotomicReference`
    - 将它的引用存储到正确创建的对象的final域中
    - 或者将它的引用存储到由锁保护的域中 